# 41. First Missing Positive

https://leetcode.com/problems/first-missing-positive/

_Темы_: **in-place**

---

Пусть $n =$ `nums.Length`, $x$ – искомое число. Заметим, что $1 \le x \le n + 1$. Если возможно за $O(1)$ проверять принадлежность $y : 1 \le y \le n$ массиву `nums`, то находить $x$ можно за $O(n)$ времени, проверив каждое возможное значение $y$: если все $y$ лежат в `nums`, то $x = n + 1$, иначе $x$ равен минимальному $y$, не лежащему в `nums`.

Нам нельзя выделять произвольное количество дополнительной памяти, но не запрещается менять массив `nums`, тогда можно преобразовать его так, чтобы выполнялось условие: если $y : 1 \le y \le n$ находится в `nums`, то `nums[y - 1]` $= y$. Добиться этого можно так:

Пусть $a$ – начальное состояние массива `nums`. Запустим цикл по $i = 0 .. n-1$ и на каждой итерации будем поддерживать инвариант: для любого $j : 0 \le j \le i$ если $1 \le a[j] \le n$, то `nums[a[j] - 1]` $= a[j]$. Для этого достаточно на каждой итерации менять местами `nums[nums[i] - 1]` и `nums[i]`, пока $1 \le$ `nums[i]` $\le n$ и `nums[nums[i] - 1]` $\ne$ `nums[i]`.

Действительно, если для каждой предыдущей итерации инвариант выполнялся, то на текущей итерации достаточно удостовериться, что если $1 \le a[i] \le n$, то `nums[a[i] - 1]` $= a[i]$, ведь после того, как $a[i]$ встаёт в нужное место, мы его никуда не двигаем. Если $1 \le a[i] \le n$, то возможны два случая:

- `nums[i]` $= a[i]$, значит, $a[i]$ не переставляли. Тогда либо условие уже выполнено, либо произойдёт перестановка `nums[nums[i] - 1]` и `nums[i]`, а значит к концу итерации `nums[a[i] - 1]` $= a[i]$.
- `nums[i]` $\ne a[i]$, значит, $a[i]$ переставили на $k$-й итерации ($k < i$) на индекс $k$, но т.к. элементы переставлялись, пока `nums[nums[k] - 1]` $\ne$ `nums[k]`, то после $k$-й итерации `nums[a[i] - 1]` $= a[i]$.

Эта процедура требует $O(n)$ времени, потому что, кроме $n$ обновлений счётчика $i$, мы выполняем перестановку двух элементов не более $n$ раз, поскольку всего таких элементов в массиве не более $n$ и после того, как элемент встаёт на нужное место, мы его никуда не двигаем.

## Асимптотика

- Время: $\Theta(n)$
- Память: $O(1)$

## Решение (C#)

```csharp
public class Solution
{
    public int FirstMissingPositive(int[] nums)
    {
        int n = nums.Length;

        for (int i = 0; i < n; ++i)
        {
            while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i])
            {
                (nums[i], nums[nums[i] - 1]) = (nums[nums[i] - 1], nums[i]);
            }
        }

        for (int i = 0; i < n; ++i)
        {
            if (nums[i] != i + 1)
            {
                return i + 1;
            }
        }

        return n + 1;
    }
}
```
