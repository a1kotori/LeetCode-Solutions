# 32. Longest Valid Parentheses

https://leetcode.com/problems/longest-valid-parentheses/

_Темы_: **dynamic-programming**

---

Пусть $n =$ `s.Length`. Будем для каждого $i : 0\le i < n$ считать $f(i)$ – длину наибольшей правильной скобочной последовательности (ПСП), оканчивающейся на $i$-м индексе. Тогда ответ: $\max_{0 \le i < n} f(i)$.

Если $s[i] =$ `'('` или $i=0$, то, очевидно, $f(i) = 0$. Иначе $s[i] =$ `')'`, $i > 0$. Попробуем тогда найти индекс $j < i : s[j] =$ `'('` и $s[j+1..i-1]$ – ПСП (возможна пустая подстрока, т.е. $j=i-1$).

- Если такой индекс нашёлся, то $s[j..i]$ также является ПСП, но необязательно наибольшей по длине:
  - Если $j=0$, то $f(i)=i + 1$.
  - Если $j > 0$, то, очевидно, $f(i) \ge$ `s[j..i].Length` $+ f(j - 1) = f(j-1)+i-j+1$. Т.к. $s[i-f(i)+1..i]$ – ПСП, то $s[i-f(i)+1..j-1]$ – ПСП, тогда $f(j-1)$ по определению не меньше её длины $j-1-(i-f(i)+1)+1=j-1-i+f(i)$, выходит $f(j-1)+i-j+1 \ge f(i)$. Значит $f(i) = f(j-1)+i-j+1$.
- Иначе $f(i)=0$, т.к. если $f(i)>0$, то, при $j=i-f(i)+1$, $s[j..i]$ – ПСП, значит $s[j] =$ `'('` и $s[j+1..i-1]$ тоже ПСП (`""` считается ПСП), а предполагалось, что такого индекса $j$ нет.

Как быстро находить такой $j$? Если $i-1-f(i - 1) \ge 0$ и $s[i-1-f(i - 1)]=$ `'('`, то можно взять $j=i-1-f(i-1)$. Иначе такого $j$ не существует:

Действительно, предположим, существует такой $j$ и пусть $l=i-1-f(i-1)$. Если $l \ge 0$, то $s[l] =$ `')'`, значит $j \ne l$, а если $j < l$, то $s[j+1..i-1]$ – ПСП с концом в $i - 1$ и длиной $i-1-(j+1)+1 = i - 1 - j > i - 1 - l = f(i - 1)$, что противоречит определению $f(i - 1)$. Значит $j > l$ и получается $s[j..i]$ – ПСП, следовательно, $s[j..i-1]$ не является ПСП, поскольку ей не хватает `')'` в конце, но тогда и $s[l+1..i-1]$ не хватает `')'` в конце и не является ПСП, противоречие с определением $f(i - 1)$.

## Асимптотика

- Время: $\Theta(n)$
- Память: $\Theta(n)$

## Решение (C#)

```csharp
public class Solution
{
    public int LongestValidParentheses(string s)
    {
        int ans = 0;
        int[] maxLength = new int[s.Length];

        for (int i = 1; i < s.Length; ++i)
        {
            if (s[i] == '(')
            {
                continue;
            }

            int j = i - 1 - maxLength[i - 1];

            if (j >= 0 && s[j] == '(')
            {
                maxLength[i] = j == 0 ? i + 1 : maxLength[j - 1] + i - j + 1;
            }

            ans = Math.Max(ans, maxLength[i]);
        }

        return ans;
    }
}
```
